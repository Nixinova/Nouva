// root level
start: unit*

// blocks of code
unit: statement | block | control_block | function_decl | class_decl

block: "{" unit* "}"
func_block: "{" (unit | return_statement)* "}"
    return_statement: /\breturn\b/ expression ";"

control_block: if_block | while_block | for_block | switch_block
if_block: /\bif\b/ expression block [else_block]
else_block: /\belse\b/ [if_block | block]
while_block: /\bwhile\b/ expression block
for_block: /\bfor\b/ identifier ":" expression block
switch_block: /\bswitch\b/ expression "{" switch_body "}"
    switch_body: (switch_case | switch_default)*
        // TODO: split into switch_block_body (uses `block`) and switch_expression_body (uses `func_block`)
        switch_case: /\bcase\b/ expression_list "->" (func_block | expression ";")
        switch_default: /\bdefault\b/ "->" (func_block | expression ";")

function_decl: /\bfunc\b/ identifier params_list func_block
class_decl: /\bclass\b/ identifier "{" class_body "}"
    class_body: (instance_statement | method | constructor)*
        instance_statement: instance_declaration | instance_definition
            instance_declaration: var_keyword identifier ["=" definition_expression] ";"
            instance_definition: identifier "=" definition_expression ";"
        method: /\bfunc\b/ identifier params_list func_block
        constructor: params_list func_block

// line of code
statement: [declaration | definition | reassignment | unary_reassignment] ";"
declaration: var_keyword identifier ["=" definition_expression]
definition: identifier "=" definition_expression
reassignment: identifier reassignment_op expression
    reassignment_op: sym_pluseq | sym_mineq | sym_multeq | sym_diveq
        | sym_bitandeq | sym_bitoreq | sym_bitxoreq | sym_bitlshifteq | sym_bitrshifteq
        | sym_logandeq | sym_logoreq
        sym_pluseq: "+="
        sym_mineq: "-="
        sym_multeq: "*="
        sym_diveq: "/="
        sym_bitandeq: "&="
        sym_bitoreq: "|="
        sym_bitxoreq: "#="
        sym_bitlshifteq: "<<="
        sym_bitrshifteq: ">>="
        sym_logandeq: "&&="
        sym_logoreq: "||="
unary_reassignment: identifier unary_reassignment_op
    unary_reassignment_op: sym_inverteq
        sym_inverteq: "=!="

// expressions
expression: null | boolean | number | string | range
    | array
    | identifier
    | function_invocation
    | array_getter | map_getter
    | typed_expression
    | unary_expression
    | math_expression
    | bitwise_expression
    | logical_expression
    | comparison_expression
    | block_expression
    | parenth_expression

definition_expression: expression | map

function_invocation: identifier "(" expression_list ")"
array_getter: identifier "[" expression "]"
map_getter: identifier "." map_key ["(" expression_list ")"]

typed_expression: identifier ":" expression
unary_expression: unary_op expression
    unary_op: sym_positive | sym_negative | sym_lognot | sym_bitnot
        sym_positive: "+"
        sym_negative: "-"
        sym_lognot: "!"
        sym_bitnot: "~"
math_expression: expression (sym_exponent) expression
    | expression (sym_multiply | sym_divide) expression
    | expression (sym_add | sym_subtract) expression
    sym_add: "+"
    sym_subtract: "-"
    sym_multiply: "*"
    sym_divide: "/"
    sym_exponent: "^"
bitwise_expression: expression bitwise_op expression
    bitwise_op: sym_bitand | sym_bitor | sym_bitxor | sym_bitlshift | sym_bitrshift
        sym_bitand: "&"
        sym_bitor: "|"
        sym_bitxor: "#"
        sym_bitlshift: "<<"
        sym_bitrshift: ">>"
logical_expression: expression logical_op expression
    logical_op: sym_logand | sym_logor
        sym_logand: "&&"
        sym_logor: "||"
comparison_expression: expression comparison_op expression
    comparison_op: sym_equals | sym_nequals | sym_less | sym_leq | sym_greater | sym_geq
        sym_equals: "=="
        sym_nequals: "!="
        sym_less: "<"
        sym_leq: "<="
        sym_greater: ">"
        sym_geq: ">="

block_expression: function_expression | lambda_expression | switch_block
    function_expression: /\bfunc\b/ params_list func_block
    lambda_expression: /\bfunc\b/ params_list "=>" expression

parenth_expression: "(" expression ")"

// keywords
var_keyword: /\bvar\b/ | /\bval\b/

// atomics
identifier: [sym_private] word_char id_char*
    sym_private: "#"

null: /\bnull\b/
boolean: /\btrue\b/ | /\bfalse\b/
number: based_number | numeral
    numeral: /\d*\.?\d+/
    based_number: /\d+_[0-9a-zA-Z]*\.?[0-9a-zA-Z]+/
string: "\"" string_char* "\""
array: "[" ([number ":"] expression [","])* "]"
map: "{" (map_key ":" expression [","])* "}"
range: expression ".." [expression] | [expression] ".." expression

// language shortcut elements
expression_list: (expression [","])*
params_list: "(" (identifier [","])* ")"
map_key: identifier | string

// fundamentals
any: /./
digit: /[0-9]/
word_char: /[a-zA-Z_]/
string_char: /[^"]/ | "\\" any
id_char: word_char | digit

// comments
%ignore /\/\/.*/
%ignore /\/\*[\s\S]*\*\//

// ignores
%ignore /\s/
