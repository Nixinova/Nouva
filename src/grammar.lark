// root level
start: unit*

// blocks of code
unit: statement | block | control_block | function_decl

block: "{" unit* "}"

control_block: if_block | while_block | for_block | switch_block
if_block: /\bif\b/ expression block [else_block]
else_block: /\belse\b/ [if_block | block]
while_block: /\bwhile\b/ expression block
for_block: /\bfor\b/ identifier ":" expression block
switch_block: /\bswitch\b/ expression "{" switch_body "}"
    switch_body: (switch_case | switch_default)*
        switch_case: /\bcase\b/ expression_list block
        switch_default: /\bdefault\b/ block

function_decl: /\bfunction\b/ identifier params_list block

// line of code
statement: [declaration | definition | expression | reassignment | unary_reassignment] ";"
declaration: var_keyword identifier ["=" definition_expression]
definition: identifier "=" definition_expression
reassignment: identifier reassignment_op expression
    reassignment_op: sym_pluseq | sym_mineq | sym_multeq | sym_diveq
        | sym_bitandeq | sym_bitoreq | sym_bitxoreq | sym_bitlshifteq | sym_bitrshifteq
        | sym_logandeq | sym_logoreq
        sym_pluseq: "+="
        sym_mineq: "-="
        sym_multeq: "*="
        sym_diveq: "/="
        sym_bitandeq: "&="
        sym_bitoreq: "|="
        sym_bitxoreq: "#="
        sym_bitlshifteq: "<<="
        sym_bitrshifteq: ">>="
        sym_logandeq: "&&="
        sym_logoreq: "||="
unary_reassignment: identifier unary_reassignment_op
    unary_reassignment_op: sym_inverteq
        sym_inverteq: "=!="

// expressions
expression: null | boolean | number | string | range
    | array
    | identifier
    | function_invocation
    | array_getter | map_getter
    | typed_expression
    | unary_expression
    | math_expression
    | bitwise_expression
    | logical_expression
    | comparison_expression
    | function_expression | lambda_expression
    | parenth_expression

definition_expression: expression | map

function_invocation: identifier "(" expression_list ")"
array_getter: identifier "[" expression "]"
map_getter: identifier "." map_key ["(" expression_list ")"]

typed_expression: identifier ":" expression
unary_expression: unary_op expression
    unary_op: sym_positive | sym_negative | sym_lognot | sym_bitnot
        sym_positive: "+"
        sym_negative: "-"
        sym_lognot: "!"
        sym_bitnot: "~"
math_expression: expression (sym_exponent) expression
    | expression (sym_multiply | sym_divide) expression
    | expression (sym_add | sym_subtract) expression
    sym_add: "+"
    sym_subtract: "-"
    sym_multiply: "*"
    sym_divide: "/"
    sym_exponent: "^"
bitwise_expression: expression bitwise_op expression
    bitwise_op: sym_bitand | sym_bitor | sym_bitxor | sym_bitlshift | sym_bitrshift
        sym_bitand: "&"
        sym_bitor: "|"
        sym_bitxor: "#"
        sym_bitlshift: "<<"
        sym_bitrshift: ">>"
logical_expression: expression logical_op expression
    logical_op: sym_logand | sym_logor
        sym_logand: "&&"
        sym_logor: "||"
comparison_expression: expression comparison_op expression
    comparison_op: sym_equals | sym_nequals | sym_less | sym_leq | sym_greater | sym_geq
        sym_equals: "=="
        sym_nequals: "!="
        sym_less: "<"
        sym_leq: "<="
        sym_greater: ">"
        sym_geq: ">="
function_expression: /\bfunction\b/ params_list block
lambda_expression: "@" params_list "=>" expression
parenth_expression: "(" expression ")"

// keywords
var_keyword: /\bvar\b/ | /\bval\b/

// atomics
identifier: word_char id_char*

null: /\bnull\b/
boolean: /\btrue\b/ | /\bfalse\b/
number: based_number | numeral
    numeral: /\d*\.?\d+/
    based_number: /\d+_[0-9a-zA-Z]*\.?[0-9a-zA-Z]+/
string: "\"" string_char* "\""
array: "[" ([number ":"] expression [","])* "]"
map: "{" (map_key ":" expression [","])* "}"
range: expression ".." [expression] | [expression] ".." expression

// language shortcut elements
expression_list: (expression [","])*
params_list: "(" (identifier [","])* ")"
map_key: identifier | string

// fundamentals
any: /./
digit: /[0-9]/
word_char: /[a-zA-Z_]/
string_char: /[^"]/ | "\\" any
id_char: word_char | digit

// comments
%ignore /\/\/.*/
%ignore /\/\*[\s\S]*\*\//

// ignores
%ignore /\s/
